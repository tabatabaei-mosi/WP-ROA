from pathlib import Path

from loguru import logger


from constraints import logical_constraint, physical_penalty
from log import (bat_summary, copy_to_history, save_charts, save_gbf,
                 simulation_info, track_npv, track_solution, write_best)
from npv_constants import constants
from optimizer import ROA
from utils import (count_calls, decode_solution, npv_calculator, path_check,
                   run_simulator, write_solution, tuning)


@count_calls
def obj_func(solution):
    """
    The objective function for optimizer. The fitness value objtained by this function may minimuze or maximuze.

    Args:
        solution (np.array, list): a solution that generated by algorithm

    Retrun:
        Fitness value (float): NPV value
    """

    # Decode solution
    locs_inj, perfs_inj, locs_prod, perfs_prod = decode_solution(
                                                        solution=solution,
                                                        num_inj=num_inj,
                                                        num_prod=num_prod,
                                                        n_params=n_params
                                                    )
    
    # Check for logical constraints
    logical_flag = logical_constraint(
                    locs_inj=locs_inj,
                    perfs_inj=perfs_inj,
                    locs_prod=locs_prod,
                    perfs_prod=perfs_prod,
                )
    
    # Check for physical constraints
    null_drilling, num_faults =  physical_penalty(
                                            model_name=model_name,
                                            locs_inj=locs_inj,
                                            perfs_inj=perfs_inj,
                                            locs_prod=locs_prod,
                                            perfs_prod=perfs_prod,
                                            gridsize=gridsize, 
                                            targets=['null_block', 'min_space', 'border'],
                                            well_space=well_space,
                                            null_space=null_space
                                        )
    
    # If a logical constraint violated or drilling a well in null blocks -> NPV = 0
    if logical_flag or null_drilling:
        return 0
    
    else:
        # write solution to INCLUDE files
        write_solution(
                locs_inj=locs_inj,
                perfs_inj=perfs_inj,
                locs_prod=locs_prod,
                perfs_prod=perfs_prod,
                keywords=keywords, 
                is_green=True, is_include=True
            )
        
        # run simulator
        run_simulator()

        # Get nfe and sim_call value from counter decorator
        nfe = obj_func.call_count
        sim_call = run_simulator.call_count

        # Track each solution and append it to a file
        track_solution(
                    solution=solution, 
                    nfe=nfe, sim_call=sim_call, 
                    n_params=n_params
                )

        # calculate NPV by reading .RSM file (resuled from simulation)
        npv = npv_calculator(
                model_name=model_name, 
                npv_constants=npv_constants
            )
        
        # Punish the algorithm based on the number of faults and penalty_coeff
        if num_faults >= 1:
            punishment_frac = penalty_coeff * num_faults

            # if punishment fraction is larger than 1 -> NPV = 0
            if punishment_frac >= 1:
                return 0
        
            # Reduced NPV by penalty coeff.
            else:       
                npv -= (punishment_frac * npv)
        
        # Track npv value and appent to a file
        track_npv(
                sim_call=sim_call, 
                npv=npv
            )
        
        return npv


# number of injections, productions and number of optimization paramaeters
num_inj = 0
num_prod = 6
n_params = 4

# specify working keywords
keywords = ['WELSPECS', 'COMPDAT']

# Enter the model name (.DATA name)
model_name = 'PUNQS3'

# GRID_SIZE -- PUNQS3
gridsize = (19, 28, 5)

num_wells = num_inj + num_prod
npv_constants = constants

# penalty coefficient
penalty_coeff = 0.2

# Minumm well spacing
# Minimum distance to null blocks
well_space, null_space = 2, 2

# Path of root directory (absolute to src)
abs_to_src = Path(__file__).resolve().parent

# Define a directory to save the log files
log_dir = f'{abs_to_src}/log_dir'
path_check(log_dir)


# PUNQS3 DATA
problem_dict = {
    'name': 'Well Placement',
    'fit_func': obj_func, 
    "lb": [1, 1, 1, 1] * num_wells,         # lower boundary to [loc_i, loc_j, perf_k1, perf_k2]
    'ub': [19, 28, 5, 5] * num_wells,       # upper boundary to [loc_i, loc_j, perf_k1, perf_k2]
    'minmax': 'max', 
    'log_to': 'file',
    'log_file': f'{log_dir}/ROAlog.log'
}

# Create an used optimizer instance
optimizer = ROA.BaseROA()

# Flag to determine if hyperparameter tuning should be performed
is_tuning = True

if is_tuning:
    # Hyperparameter grid for tuning
    params_roa_grid = {
        'epoch': [5],
        'pop_size': [15],
        'init_radius': [0.8, 1.0, 1.2],
        'joint_size': [1.0],
        'rain_speed': [2],
        'soil_adsorption': [0.8, 1.0, 1.2]
    }

    # mode and number of trials on the problem
    mode = 'single'
    n_trials = 3

    # Perform hyperparameter tuning using the 'tuning' function
    tuning(
        optimizer=optimizer,
        problem_dict=problem_dict,
        params_grid=params_roa_grid,
        mode=mode,
        n_trials=n_trials
    )

else:
    # Set fixed parameters if not tuning
    parameters_dict = {
        'epoch': 10,
        'pop_size': 20,
        'init_radius': 1.0,
        'joint_size': 2,
        'rain_speed': 2,
        'soil_adsorption': 5,
    }

    # Set the parameters for the optimizer
    optimizer.set_parameters(parameters=parameters_dict)

    # Solve the optimization problem with the chosen parameters
    best_position, best_fitness = optimizer.solve(problem=problem_dict)

    # Log the best solution and best fitness
    logger.info(f"Solution: {best_position.astype(int)}, Fitness: {best_fitness}")

    # Summarize information from simulation log file and generate a summary
    bat_summary()

    # Write optimization results and perform simulation with the best solution.
    write_best(
            model_name=model_name,
            optimizer=optimizer,
            best_solution=best_position,
            best_fitness=best_fitness,
            sim_call=run_simulator.call_count,
            num_prod=num_prod,
            num_inj=num_inj,
            n_params=4,
            gridsize=gridsize,
            keywords=keywords
        )

    # Saving the global best fitness values of each epoch to excel file
    save_gbf(optimizer=optimizer)

    # Defining a list of charts for saving them
    # ... based on optimizer.history, ex.: optimizer.history.save_global_best_fitness_chart -
    # - target = 'global_best_fintess' or optimizer.history.save_{target}_chart
    chart_targets = ['global_best_fitness',
                        'exploration_exploitation',
                ]
    # Saving the desired charts.
    save_charts(optimizer=optimizer,
                targets=chart_targets
            )

    # Write the simulation run information with the best solution
    simulation_info()

    # Copy the log files from log_dir to run_history
    copy_to_history(optimizer=optimizer)